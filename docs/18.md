手写call、apply、bind、函数柯里化

## call
原理都在注释里了
```js
// 不覆盖原生call方法，起个别名叫myCall，接收this上下文context和参数params
Function.prototype.myCall = function (context, ...params) {
  // context必须是个对象并且不能为null，默认为window
  const _this = typeof context === "object" ? context || window : window;
  // 为了避免和原有属性冲突，定义一个Symbol类型的属性
  const key = Symbol();
  // call方法的目的是改变函数的this指向，函数的this指向它的调用者，也就是说我们的目标是改变函数的调用者。
  // 下面的this就是函数本身，给context增加一个名为[key]的方法指向this，就能用context来调用this了
  context[key] = this;
  const result = _this[key](...params);
  // 获取函数执行结果后，删除以上添加的属性
  delete context[key];
  return result;
};
```

## apply
和call的区别在于第二个参数
```js
Function.prototype.myApply = function (context, params) {
  return this.myCall(context, ...params);
};
```

## bind
和call的区别在于不立即执行，返回一个函数即可
```js
Function.prototype.myBind = function (context, ...params) {
  const _this = this;
  // 返回的函数也能接收参数，但是是放在params后面
  return function (...args) {
    return _this.myCall(context, ...[...params, ...args]);
  };
};
```

## 函数柯里化
