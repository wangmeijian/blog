# React中共享组件逻辑的三种方式

废话少说，这三种方式分别是：render props、高阶组件和自定义Hook。下面依次演示

假设有一个```TimeOnPage```组件专门用来记录用户在当前页面停留时间，像这样：

```js
const TimeOnPage = () => {
  const [second, setSecond] = useState(0);

  useEffect(() => {
    setTimeout(() => {
      setSecond(second + 1);
    }, 1000);
  }, [second]);
  return (
    <div>停留时间：{second}秒</div>
  );
}
```
如果另一个组件需要复用这个功能，我们能否封装一下，以便轻松地与其它组件共享？

一般很自然地想到子组件嵌套的方式，利用props传参

```js
const Child = (props) => {
  return <div>stayTime: {props.stayTime}s</div>;
};

const TimeOnPage = () => {
  const [second, setSecond] = useState(0);

  useEffect(() => {
    setTimeout(() => {
      setSecond(second + 1);
    }, 1000);
  }, [second]);
  return (
    <div>
      <Child stayTime={second} />
    </div>
  );
}
```

这属于在 ```TimeOnPage```组件内部硬编码，还没有达到封装复用的目标。看看render props怎么做？

## render props

 > “render prop” 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术

接上文，在TimeOnPage里定义一个值为函数的prop，想渲染什么组件，在函数里返回即可，函数的参数就是想要共享的状态。

```js
const Child = (props) => {
  return <div>stayTime: {props.stayTime}s</div>;
};

const TimeOnPage = (props) => {
  const [second, setSecond] = useState(0);

  useEffect(() => {
    setTimeout(() => {
      setSecond(second + 1);
    }, 1000);
  }, [second]);
  return <div>{props.render(second)}</div>;
};

<TimeOnPage render={(stayTime) => <Child stayTime={stayTime} />
```
其实，render prop 就是一个用于告知组件需要渲染什么内容的函数prop。

React Router就用到了这项技术

```html
<Router>
  <Route path="/home" render={() => <div>Home</div>} />
</Router>
```

## 高阶组件

> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

高阶组件是一个函数，参数是一个需要复用的组件A，返回值是一个新的组件N。新组件N是在组件A的基础上做了一些加工，但不会修改组件C本身，只是功能增强。

假设有一个新闻列表组件长这样：

```js
const NewList = () => {
  return (
    <div>
      <ul>
        <li>news item</li>
        <li>news item</li>
      </ul>
    </div>
  );
}
```
想要在新闻列表加载期间显示loading动画组件 ```<Loading />```，通常会这么做

```js
const Loading = () => {
  // loading动画
}
const NewList = ({ loading }) => {
  return loading ? (
    <Loading />
  ) : (
    <div>
      <ul>
        <li>news item</li>
        <li>news item</li>
      </ul>
    </div>
  );
};
```
假设现在Table组件也要在加载数据期间显示loading动画组件，遵循类似的模式

```js
const Loading = () => {
  // loading动画
}
const DataList = ({ loading, ...props }) => {
  return loading ? (
    <Loading />
  ) : (
    <Table {...props} />
  );
};
```
以上，你会发现DataList和NewList结构极度相似，如果还有第三个、第四个组件要加loading，继续照这个模式重复第三次、第四次吗？这不是一种好的做法，更好的做法是，使用高阶组件把这个模式抽象出来：

```js
const WithLoading = (WrappedComponent) => {
  return ({loading, ...props}) => {
    return loading ? <Loading /> : <WrappedComponent {...props} />;
  }
};
```

然后就可以在不修改NewList和DataList的情况下分别给他们增加loading了

```js
const NewList = () => {
  return (
    <div>
      <ul>
        <li>news item</li>
        <li>news item</li>
      </ul>
    </div>
  );
};

const DataList = (props) => {
  return <Table {...props} />
};

const WithLoading = (WrappedComponent) => {
  return ({loading, ...props}) => {
    return loading ? <Loading /> : <WrappedComponent {...props} />;
  }
};
// 带loading的NewList
const WithLoadingNewList = WithLoading(<NewList />)
// 带loading的DataList
const WithLoadingDataList = WithLoading(<DataList />)
```

这就是高阶组件的魔力

