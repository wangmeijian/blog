(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{410:function(n,e,p){"use strict";p.r(e);var a=p(46),o=Object(a.a)({},(function(){var n=this,e=n.$createElement,p=n._self._c||e;return p("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[p("h1",{attrs:{id:"pnpm凭什么这么快"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#pnpm凭什么这么快"}},[n._v("#")]),n._v(" pnpm凭什么这么快")]),n._v(" "),p("p",[n._v("前端包管理器层出不穷，pnpm算是一个后起之秀。它和npm有什么不同，为什么有了npm还要造一个pnpm？")]),n._v(" "),p("h2",{attrs:{id:"npm的问题"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#npm的问题"}},[n._v("#")]),n._v(" npm的问题")]),n._v(" "),p("p",[n._v("npm是最早的包管理器，安装nodejs自带npm，v3版本之前，npm安全依赖的目录结构是这样的：")]),n._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[n._v("node_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n")])])]),p("p",[n._v("结构清晰而直观，但是存在一个明显的问题，当依赖层级过多时，文件嵌套非常深，然而window系统对文件路径长度是有限制的，超过256字符就会出现目标路径太长，从而无法操作深层级文件的问题，从v3版本开始，npm将每个package平铺到node_modules，就像这样")]),n._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[n._v("node_modules\n├─ foo\n|  ├─ index.js\n|  └─ package.json\n└─ bar\n   ├─ index.js\n   └─ package.json\n")])])]),p("p",[n._v("平铺的方式解决了长路径的问题，但是又存在另一些问题：")]),n._v(" "),p("p",[p("strong",[n._v("package依赖不直观，所有package都是平级的，无法看出来谁依赖了谁")]),n._v("；")]),n._v(" "),p("p",[p("strong",[n._v("项目中可以直接import间接依赖的package")]),n._v("，比如模块A依赖了模块B，开发者可以直接在项目中import模块B，当模块A升级之后，可能依赖的模块B版本也升级了，之前直接import模块B的API可能不再兼容；")]),n._v(" "),p("p",[n._v("除此之外，"),p("strong",[n._v("npm的另外一个问题是，如果你有10个项目中依赖了模块A，模块A将被安装10次，并且在你的硬盘上保存了10份一模一样的代码，占用了大量磁盘空间")])]),n._v(" "),p("p",[n._v("pnpm的作者意识到这些问题，站出来造了pnpm这个新轮子，加入了一些创新")]),n._v(" "),p("h2",{attrs:{id:"pnpm的解决方案"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#pnpm的解决方案"}},[n._v("#")]),n._v(" pnpm的解决方案")]),n._v(" "),p("p",[n._v("pnpm的口号是“快速的，节省磁盘空间的包管理工具”，这就是pnpm名字的由来，pnpm代表 performant（高性能的）npm，那么它是怎么做到快且节省磁盘空间的？")]),n._v(" "),p("p",[n._v("当项目中安装依赖包时，pnpm将所有依赖包存储在磁盘的某一个位置，简称"),p("code",[n._v(".pnpm store")]),n._v("，下次再安装同一个包的时候，如果"),p("code",[n._v(".pnpm store")]),n._v("已经存在这个包，将会在项目中创建一个硬链接到"),p("code",[n._v(".pnpm store")]),n._v("（"),p("a",{attrs:{href:"https://github.com/wangmeijian/blog/issues/10",target:"_blank",rel:"noopener noreferrer"}},[n._v("什么是硬链接？"),p("OutboundLink")],1),n._v("），如果"),p("code",[n._v(".pnpm store")]),n._v("不存在这个包，会先保存这个包到"),p("code",[n._v(".pnpm store")]),n._v("，然后再创建硬链接。这样设计，即使是10个项目都依赖了同一个版本的模块A，模块A也只在磁盘上保存1份代码，这就是pnpm又快又节省磁盘空间的原因")]),n._v(" "),p("h2",{attrs:{id:"pnpm的实现方式"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#pnpm的实现方式"}},[n._v("#")]),n._v(" pnpm的实现方式")]),n._v(" "),p("p",[n._v("pnpm的node_modules并不是平铺的，举例：")]),n._v(" "),p("p",[n._v("某个项目使用了模块"),p("code",[n._v("foo@1.0.0")]),n._v("，模块"),p("code",[n._v("foo@1.0.0")]),n._v("又依赖了模块"),p("code",[n._v("bar@1.0.0")]),n._v("，那么安装依赖后的node_modules结构是这样的：")]),n._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[n._v("node_modules\n├── foo -> ./.pnpm/foo@1.0.0/node_modules/foo\n└── .pnpm\n    ├── bar@1.0.0\n    │   └── node_modules\n    │       └── bar -> <store>/bar\n    └── foo@1.0.0\n        └── node_modules\n            ├── foo -> <store>/foo\n            └── bar -> ../../bar@1.0.0/node_modules/bar\n")])])]),p("p",[n._v("node_modules根目录下只有项目直接依赖的foo模块的软链接和一个.pnpm隐藏文件夹，.pnpm文件夹内，以平铺的方式存放着所有包，每个包文件夹都能一眼看出依赖关系")]),n._v(" "),p("p",[n._v("foo模块以及依赖的bar模块的真实文件，都是存放在"),p("code",[n._v(".pnpm store")]),n._v("，通过硬链接的方式使用")]),n._v(" "),p("p",[p("img",{attrs:{src:"https://user-images.githubusercontent.com/9384140/185889660-68ae3d8f-b91a-4e7a-91bd-2cd6c44ca2ee.png",alt:"pnpmstore"}})]),n._v(" "),p("h2",{attrs:{id:"总结"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),p("p",[n._v("pnpm在重复安装依赖包时，不需要复制文件，所以速度非常快，通过硬链接的方式共享同一份代码，极大的节省了磁盘空间")])])}),[],!1,null,null,null);e.default=o.exports}}]);